<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="描述"><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>java面试题(其一) | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"></head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">Hexo</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">java面试题(其一)</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2020/08/01/java%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%85%B6%E4%B8%80/">2020-08-01</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/java/">java</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h4 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h4><h5 id="1-JDK和-JRE-有什么区别？"><a href="#1-JDK和-JRE-有什么区别？" class="headerlink" title="1.JDK和 JRE 有什么区别？"></a>1.JDK和 JRE 有什么区别？</h5><p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</p>
<p>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</p>
<a id="more"></a>

<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>
<h5 id="2-Java-内存区域"><a href="#2-Java-内存区域" class="headerlink" title="2.Java 内存区域"></a>2.Java 内存区域</h5><p>Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、元数据区。</p>
<p>JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。</p>
<p>为什么要使用元空间取代永久代的实现？</p>
<ol>
<li><p>字符串存在永久代中，容易出现性能问题和内存溢出。</p>
</li>
<li><p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p>
</li>
<li><p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
</li>
<li><p>将 HotSpot 与 JRockit 合二为一。</p>
</li>
</ol>
<h5 id="3-和-equals-的区别是什么？"><a href="#3-和-equals-的区别是什么？" class="headerlink" title="3. == 和 equals 的区别是什么？"></a>3. == 和 equals 的区别是什么？</h5><p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p>
<p>equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h5 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a>4. final 在 Java 中有什么作用？</h5><p>final 修饰的类叫最终类，该类不能被继承。<br>   final 修饰的方法不能被重写。<br>   final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h5 id="5-String-类的常用方法都有那些？"><a href="#5-String-类的常用方法都有那些？" class="headerlink" title="5. String 类的常用方法都有那些？"></a>5. String 类的常用方法都有那些？</h5><ul>
<li><p>indexOf()：返回指定字符的索引。</p>
</li>
<li><p>charAt()：返回指定索引处的字符。</p>
</li>
<li><p>replace()：字符串替换。</p>
</li>
<li><p>trim()：去除字符串两端空白。</p>
</li>
<li><p>split()：分割字符串，返回一个分割后的字符串数组。</p>
</li>
<li><p>getBytes()：返回字符串的 byte 类型数组。</p>
</li>
<li><p>length()：返回字符串长度。</p>
</li>
<li><p>toLowerCase()：将字符串转成小写字母。</p>
</li>
<li><p>toUpperCase()：将字符串转成大写字符。</p>
</li>
<li><p>substring()：截取字符串。</p>
</li>
<li><p>equals()：字符串比较。</p>
</li>
</ul>
<h5 id="6-Java-容器都有哪些？"><a href="#6-Java-容器都有哪些？" class="headerlink" title="6. Java 容器都有哪些？"></a>6. Java 容器都有哪些？</h5><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>Collection</p>
<p>List、ArrayList、LinkedList、Vector、Stack、Set、HashSet、LinkedHashSet、TreeSet</p>
<p>Map</p>
<p>HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap、Hashtable</p>
<h5 id="7-数组与链表的区别"><a href="#7-数组与链表的区别" class="headerlink" title="7. 数组与链表的区别"></a>7. 数组与链表的区别</h5><p>1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；　</p>
<p>2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；　</p>
<p>3、存储空间上，链表由于带有指针域，存储密度不如数组大；　</p>
<p>4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；　</p>
<p>5、按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；　</p>
<p>6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；　</p>
<p>7、空间分配方面：<br> 　数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；<br> 　链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；</p>
<h5 id="8-Map集合几种遍历方式"><a href="#8-Map集合几种遍历方式" class="headerlink" title="8. Map集合几种遍历方式?"></a>8. Map<strong>集合几种遍历方式?</strong></h5><p>第一种:根据键找值方式遍历</p>
<p>第二种:获取所有的键值对对象集合,通过迭代器遍历</p>
<p>第三种:获取所有的键值对对象集合,通过增强for遍历</p>
<p>第四种:通过Map集合中values方法,拿到所有的值</p>
<h5 id="9-List集合的特性"><a href="#9-List集合的特性" class="headerlink" title="9. List集合的特性"></a>9. List集合的特性</h5><p>ArrayList</p>
<p>  1.ArrayList是List接口可变数组的实现,允许存放null</p>
<p>  2.底层是使用数组实现,无参构造函数默认初始化长度为10,数组扩容是会将原数组中的元素重新拷贝到新数组中,长度为原来的1.5+1(代扩容价高)</p>
<p>  3.线程非同步.</p>
<p>LinkedList</p>
<p>  1.LinkedList是List接口双向链表的非同步实现,允许存放null</p>
<p>  2.底层的数据结构是基于双向链表,数据结构是节点</p>
<p>  3.双向链表中每个节点分为prev,next,item,其中prev中存放上一个节点的信息,next存放下一个节点的信息,item存放该节点的值</p>
<h5 id="10-如何实现数组和-List-之间的转换？"><a href="#10-如何实现数组和-List-之间的转换？" class="headerlink" title="10. 如何实现数组和 List 之间的转换？"></a>10. 如何实现数组和 List 之间的转换？</h5><p>数组转 List：使用 Arrays. asList(array) 进行转换。<br>   List 转数组：使用 List 自带的 toArray() 方法。</p>
<p><strong>11.</strong>   <strong>ArrayList</strong> <strong>和 LinkedList 有什么区别</strong></p>
<p>ArrayList和LinkedList都实现了List接口，有以下的不同点：<br>   1、ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>   2、相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br> 3、LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<p><strong>12.</strong>   <strong>List、set和map的区别</strong></p>
<p>list和set是实现了collection接口的。</p>
<p>List：</p>
<p>1.可以允许重复的对象。</p>
<p> 2.可以插入多个null元素。</p>
<p> 3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。</p>
<p>4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。 </p>
<p>Set： </p>
<p>1.不允许重复对象</p>
<p>　　  2. 无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator  或者 Comparable 维护了一个排序顺序。</p>
<ol start="3">
<li>只允许一个 null 元素</li>
</ol>
<p>4.Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</p>
<p>Map不是collection的子接口或者实现类。Map是一个接口。</p>
<p>1.Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。</p>
<ol start="2">
<li>TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序。</li>
</ol>
<p>3.Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。</p>
<p>4.Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap。（HashMap、TreeMap最常用）</p>
<p><strong>13.</strong>   <strong>HashMap的特性</strong></p>
<p>Map集合的特点</p>
<p>一、Map是一个双列集合,将键映射到值的对象.</p>
<p>二、Map集合的数据结构,只针对键有效,跟值没关系.</p>
<p>三、一个映射不能包含重复的键,每个键最多只能映射一个值.</p>
<p> HashMap的数据结构</p>
<p>一、哈希表结构:数组+链表</p>
<p>二、通过哈希表结构配合对象的hashCode和equals方法就可以确保键的唯一性.</p>
<p>HashMap和Hashtable的区别</p>
<p>一、HashMap是jdk1.2版本出现的,允许存储null键和null值</p>
<p>不同步(线程不安全):效率高</p>
<p>二、Hashtable是jdk1.0版本出现的,不允许存储null键和null值</p>
<p>同步(线程安全):效率低</p>
<p><strong>14.</strong>   <strong>说一下 HashMap 的实现原理？</strong></p>
<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树</p>
<p><strong>15.</strong>   <strong>说一下 HashSet 的实现原理？</strong></p>
<p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<p><strong>16.</strong>   <strong>CurrentHashMap**</strong>了解吗?**</p>
<p>HashMap是线程不安全的 , 但是效率高 , HashTable是线程安全的 , 但是效率低.有没有一种对象是即是线程安全的 , 同时执行效率可以达到HashMap呢?</p>
<p>CurrentHashMap可以做到。底层实现通过分段加锁进行实现 , hashmap底层是数组加上链表实现的 , 那么一个线程来操作数据,只是操作数组中一个索引的数据. 如果此时对整个数组加锁,其他线程操作不了这个数组,所以效率低.其实线程也就操作数组的一个索引,对这个索引进行加锁 , 而锁对象就是这个索引所对应的值,其他线程来修改其他索引数据时,拿到的是其他索引的锁对象,从而提高了效率.</p>
<p><strong>17.</strong>   <strong>String,StringBuilder,StringBuffer**</strong>三者的区别**</p>
<p> String和StringBuilder的本质区别</p>
<p>String是一个不可改变的字符序列.</p>
<p>StringBuilder是一个可以改变的字符序列.</p>
<p>常见的字符拼接,该选择谁</p>
<p>推荐使用StringBuilder,因为拼接的效率高</p>
<p> StringBuilder和StringBuffer的区别</p>
<p>一、StringBuilder和StringBuffer的功能是完全一致的.</p>
<p>二、不同点</p>
<p>StringBuffer是jdk1.0出现的,线程安全(同步):效率低.</p>
<p>StringBuilder是jdk1.5出现的,线程不安全(不同步):效率高.</p>
<p><strong>18.</strong>   <strong>抽象类与接口区别</strong></p>
<p> 抽象类可以有构造方法，接口中不能有构造方法</p>
<p> 抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p> 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的</p>
<p>抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型</p>
<p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p> 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型</p>
<p> 一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p> 接口关注的是功能，抽象类关注的抽象现实中事物</p>
<p><strong>19.</strong>   <strong>类的实例化方法调用顺序</strong></p>
<p>此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。<br>   父类静态代变量、<br>   父类静态代码块、<br>   子类静态变量、<br>   子类静态代码块、<br>   父类非静态变量（父类实例成员变量）、<br>   父类构造函数、<br>   子类非静态变量（子类实例成员变量）、<br>   子类构造函数。</p>
<p><strong>20.</strong>   <strong>JAVA反射机制提供了什么功能</strong></p>
<p>Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers（诸如public, static 等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。</p>
<p>Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。</p>
<p>Java反射机制提供如下功能：</p>
<p>在运行时判断任意一个对象所属的类</p>
<p>在运行时构造任意一个类的对象</p>
<p>在运行时判段任意一个类所具有的成员变量和方法</p>
<p>在运行时调用任一个对象的方法</p>
<p>在运行时创建新类对象</p>
<p>在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。</p>
<p><strong>21.</strong>   <strong>Stream常用方法：</strong></p>
<p> map: 用作类型转换 如把集合里面的字符串转为大写,或者一个对象的集合取几个字段转为新的对象集合</p>
<p> filter: 过滤 符合条件的集合元素保存下来,不符合条件的去掉</p>
<p> flatMap:合并集合,比如List<Album> Album里面有一LIst<Track> 对象,这个时候就能不通过循环的方式把 List<Album> 里的每一个元素的 trasks 对象组装成一个新的集合</p>
<p> reduce: reduce可以做累加运算, .reduce(0, (a,b)-&gt; a+b);</p>
<p> count: count和size一样返回的是元素的个数</p>
<p>max,min: 求最大值和最小值,这两个方法需要传入一个comparator比较器,Comparator比较器有一个comparing() 方法 </p>
<p> anyMatch表示，判断的条件里，任意一个元素成功，返回true</p>
<p> allMatch表示，判断条件里的元素，所有的都是，返回true</p>
<p><strong>22.</strong>   <strong>常见的异常类有哪些？</strong></p>
<p>NullPointerException 空指针异常</p>
<p> ClassNotFoundException 指定类不存在</p>
<p> NumberFormatException 字符串转换为数字异常</p>
<p> IndexOutOfBoundsException 数组下标越界异常</p>
<p>ClassCastException 数据类型转换异常</p>
<p> FileNotFoundException 文件未找到异常</p>
<p> NoSuchMethodException 方法不存在异常</p>
<p> IOException IO 异常</p>
<p> SocketException Socket 异常</p>
<p><strong>23.</strong>   <strong>Java**</strong>中异常处理机制**</p>
<p> 什么是异常</p>
<p>异常指的就是程序的不正常,简单理解就是程序所发生的错误.</p>
<p> 异常的体系结构&amp;分类</p>
<p>一、分类</p>
<p>1)  编译时异常:指的就是编译期间,编译器检测到某段代码可能会发生某些问题,需要程序员提前给代码做出错误的解决方案,否则编译是不通过的.(例如FileReader)</p>
<p>2)  运行时异常:指的是编译通过了,但运行时出现的错误.</p>
<p>二、体系结构</p>
<p>Throwable</p>
<p>Error：严重性错误</p>
<p>Exception：</p>
<p>RuntimeException:运行时异常</p>
<p>RuntimeException:编译时异常</p>
<p>异常产生的原理</p>
<p>java对异常默认的处理方式,是将问题抛出给上一级</p>
<p>抛出之前,java会根据错误产生的异常类,创建出该类的对象,底层并通过throw关键字将异常抛出给上一级,不断向上抛出,直到抛给了JVM虚拟机,虚拟机拿到问题之后,就会将错误的原因和所在的位置,打印在控制台.</p>
<p> 异常的处理方式</p>
<p>一、问题可以自己处理掉的</p>
<p>try…catch处理方式:自己将问题处理掉,不会影响到后续代码的继续执行.</p>
<p>二、问题自己处理不掉的</p>
<p>throws抛出处理方式：如果发现问题自己无法完美结局,就可以通过throw关键字,将异常对象抛出给调用者,但如果使用throw抛出异常对象,则方法上面必须进行throws的声明,告知调用者此方法存在异常.</p>
<p>细节:如果抛出的对象是RuntimeException,则方法上面无需throws声明.</p>
<p><strong>24.</strong>   <strong>线程和进程的区别？</strong></p>
<p> 进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p> 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
<p> 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p>
<p><strong>25.</strong>   <strong>创建线程的方式</strong></p>
<p> 继承Thread类</p>
<p>优点:代码简单</p>
<p>缺点:该类无法继承别的类</p>
<p> 实现Runnable接口</p>
<p>优点:继承其他类.统一实现该接口的实例可以共享资源.</p>
<p>缺点:代码复杂.</p>
<p> 实现Callable接口</p>
<p>Callable中的call()方法有返回值,其他和Runnable的run()方法一样.</p>
<p>线程池方式</p>
<p>优点:实现自动化装配,易于管理,循环利用资源.</p>
<p><strong>26.</strong>   <strong>线程的状态</strong></p>
<p> 就绪(Runnable):线程准备运行，不一定立马就能开始执行。</p>
<p> 运行中(Running)：进程正在执行线程的代码。</p>
<p> 等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。</p>
<p>睡眠中(Sleeping)：线程被强制睡眠。</p>
<p> I/O阻塞(Blocked on I/O)：等待I/O操作完成。</p>
<p>同步阻塞(Blocked on Synchronization)：等待获取锁。</p>
<p> 死亡(Dead)：线程完成了执行。</p>
<p><strong>27.</strong>   <strong>Java**</strong>中wait方法和sleep方法的不同之处**</p>
<p> wait和sleep的基本使用:</p>
<p>wait:此方法来自于Object类,必须由锁对象进行调用</p>
<p>sleep:此方法来自于Thread类,是Thread类的静态方法,可以类名点调用</p>
<p> wait方法和sleep方法的原理对比</p>
<p>sleep:让当前程序休眠xxx毫秒,休眠之后,程序继续执行.</p>
<p>wait:如果使用的wait方法是传入毫秒值参数的,产生的效果和sleep类似,但是wait方法较为麻烦一点,wait方法必须由锁对象调用,锁对象还必须放在同步当中.</p>
<p> 总结:</p>
<p>wait方法:</p>
<p>一、空参数:会让线程进入无限等待状态,进入无限等待状态后,必须由notify方法对其进行唤醒.</p>
<p>重点:</p>
<p>wait方法在等待的过程中,释放锁对象.</p>
<p>sleep方法在休眠的过程中,不会释放锁对象.</p>
<p>二、有参数的:效果和sleep方法类似.</p>
<p><strong>28.</strong>   <strong>线程池的种类</strong></p>
<p> newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p> newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
<p> newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p>
<p>因为在项目中，线程的创建和销毁非常消耗资源，所以使用在多线程场景的时候会使用线程池，根据自己业务逻辑的需求，使用不同的线程池。</p>
<p><strong>29.</strong>   <strong>线程池都有哪些状态？</strong></p>
<p> RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p>
<p> SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p>
<p> STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p>
<p>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</p>
<p> TERMINATED：terminated()方法结束后，线程池的状态就会变成这个</p>
<p><strong>30.</strong>   <strong>线程同步</strong></p>
<p>线程同步：实现共享数据的一致性，让多个线程有序的访问共享资源，而不是同时操作共享资源</p>
<p> 方法同步：用关键字 synchonized 可将方法声明为同步</p>
<p> 同步代码块：synchornized 获取的是参数中的对象锁，synchornized(obj){}</p>
<p> 同步类的属性：在类中声明多个object对象，对每个代码块分别操作类的不同属性加锁的时候就分别使用object对象来作为锁，这样能保证多个线程同时运行，分别操作不同的对象</p>
<p> synchronized 静态方法与非静态方法：非静态同步方法的锁对象是this，静态的同步方法的锁对象是当前类的字节码对象</p>
<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</p>
<p><strong>31.</strong>   <strong>多线程中 synchronized 锁升级的原理是什么？</strong></p>
<p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<p><strong>32.</strong>   <strong>volatile与synchronized的区别，底层实现</strong></p>
<p> 首先两者都是用来确保数据的一致性的，volatile它能够使变量在值发生改变时尽快让其他线程知道，为什么要这么做呢？编译器为了加快程序运行速度，对一些变量的写操作会现在寄存器或者是cpu缓存上进行，最后才写入内存，这个过程，变量的新值对其他线程是不可见的，而volatile的作用就是使它修饰的变量的读写操作都必须在内存中进行</p>
<p>区别：</p>
<p> Volatile本质是告诉jvm当前变量在寄存器中的值是不安全的需要从内存中读取，sychronized则是锁定当前变量，只有当前线程可以访问到该变量其他线程被阻塞</p>
<p> Volatile只能作用于变量，synchronized则是可以使用在变量和方法上</p>
<p> Volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性</p>
<p> volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞</p>
<p> volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化</p>
<p>注意事项：</p>
<p> 在使用volatile关键字时要慎重，并不是只要简单类型变量使用volatile修饰，对这个变量的所有操作都是原来操作，当变量的值由自身的上一个决定时，如n=n+1、n++ 等，volatile关键字将失效，只有当变量的值和自身上一个值无关时对该变量的操作才是原子级别的，如n = m + 1，这个就是原级别的。所以在使用volatile关键时一定要谨慎，如果自己没有把握，可以使用synchronized来代替volatile</p>
<p><strong>33.</strong>   <strong>什么是死锁？</strong></p>
<p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<p><strong>34.</strong>   <strong>怎么防止死锁？</strong></p>
<p> 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</p>
<p>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</p>
<p> 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</p>
<p> 尽量减少同步的代码块。</p>
<p><strong>35.</strong>   <strong>IO**</strong>对比总结**</p>
<p> IO 的方式通常分为几种：同步阻塞的 BIO、同步非阻塞的 NIO、异步非阻塞的 AIO。 </p>
<p> BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。 </p>
<p> NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。 </p>
<p> AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。 </p>
<p>举个例子： </p>
<p>同步阻塞：你到饭馆点餐，然后在那等着，啥都干不了，饭馆没做好，你就必须等着！</p>
<p> 同步非阻塞：你在饭馆点完餐，就去玩儿了。不过玩一会儿，就回饭馆问一声：好了没 啊！ </p>
<p> 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心玩儿就可以了， 类似于现在的外卖。</p>
<p><strong>36.</strong>   <strong>反射，泛型项目中有没有使用</strong></p>
<p>反射：spring框架，底层使用大量反射，但是我们直接使用IOC注入对象，所以并不直接使用。除非特殊情况下，自己封装一些工具类的时候使用到（最后一句可以不说）。</p>
<p> 泛型：底层肯定也是大量使用的，写的工具类，返回给前端对象中，对外的参数List Map等可以使用泛型。</p>
<p><strong>37.</strong>   <strong>Java**</strong>虚拟机有哪几块内存空间**</p>
<p> 程序计数器：可以看作是当前线程所执行的字节码文件（class）的行号指示器，它会记录执行痕迹，是每个线程私有的；</p>
<p>栈：栈是运行时创建的，是线程私有的，生命周期与线程相同，存储声明的变量的</p>
<p>本地方法栈：为native方法服务，native方法是一种由非java语言实现的java方法，为什么使用这种方法呢，与java环境外交互，或者与操作系统交互</p>
<p> 堆：堆是所有线程共享的一块内存，是在java虚拟机启动时创建的，几乎所有对象实例都在此创建，所以经常发生垃圾回收操作；</p>
<p> 方法区：主要存储已被虚拟机加载的类的信息，常量，静态变量和即时编译器编译后的代码等数据，该区域是被线程共享的，很少发生垃圾回收</p>
<p><strong>38.</strong>   <strong>JAVA**</strong>中垃圾回收机制**</p>
<p> 什么样的对象会被当做垃圾回收</p>
<p>当一个对象的引用(地址)没有变量去记录的时候,该对象就会成为垃圾对象,并在垃圾回收器空闲的时候对其进行清扫.</p>
<p> 如何检验对象是否被回收</p>
<p>可以重写Object类中的finalize方法</p>
<p>这个方法在垃圾回收器执行的时候,被回收器自动调用执行的.</p>
<p>怎样通知垃圾回收器回收对象</p>
<p>可以调用system类的静态方法gc().通知垃圾回收器去清理垃圾.</p>
<p><strong>39.</strong>   <strong>类加载过程</strong></p>
<p> 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p>
<p> 加载:1.获取类的二进制字节流</p>
<p>   2.将字节流代表的静态存储结构转化为方法区运行时数据结构</p>
<p>​     3.在队中生成class字节码对象</p>
<p> 验证:连接过程的第一步,确保class文件的字节流中的信息符合当前虚拟机的要求,不会危害虚拟机的安全</p>
<p> 准备:为类的静态变量分配内存并将其初始化为默认值</p>
<p> 解析:虚拟机将常量池内符号引用替换成直接引用的过程</p>
<p> 初始化:执行类构造器的init的过程</p>
<p><strong>40.</strong>   <strong>对象创建过程</strong></p>
<p> JVM会先去方法区下找有没有所创建对象的类存在，有就可以创建对象了，没有则把该类加载到方法区</p>
<p> 在创建类的对象时，首先会先去堆内存中分配空间</p>
<p> 当空间分配完后，加载对象中所有的非静态成员变量到该空间下</p>
<p> 所有的非静态成员变量加载完成之后，对所有的非静态成员进行默认初始化</p>
<p> 所有的非静态成员默认初始化完成之后，调用相应的构造方法到栈中</p>
<p> 在栈中执行构造函数时，先执行隐式，再执行构造方法中书写的代码</p>
<p> 执行顺序：静态代码库，构造代码块，构造方法</p>
<p> 当整个构造方法全部执行完，此对象创建完成，并把堆内存中分配的空间地址赋给对象名（此时对象名就指向了该空间）</p>
<p><strong>41.</strong>   <strong>方法区堆栈溢出怎么处理</strong></p>
<p>jdk1.7之前字符串常量池是方法区的一部分，方法区叫做“永久代”，在1.7之前无限的创建对象就会造成内存溢出</p>
<p>用jdk1.7之后，取消了永久代，添加了元数据区，就不会产生内存溢出。</p>
<p>在jdk1.7时出现内存溢出：</p>
<ol>
<li><p>需要查看代码中是否出现死循环。</p>
</li>
<li><p>是否出现死锁现象。</p>
</li>
<li><p>在jvm运行时，提高堆内存的大小。</p>
</li>
</ol>
<p><strong>42.</strong>   <strong>单例设计模式中懒汉式和饿汉式的区别</strong></p>
<p> 饿汉式：</p>
<p>//饿汉式单例类.在类初始化时，已经自行实例化  </p>
<p>public class Singleton1 { </p>
<p>  private Singleton1() {} </p>
<p>  private static final Singleton1 single = new Singleton1(); </p>
<p>  //静态工厂方法  </p>
<p>  public static Singleton1 getInstance() { </p>
<p>​    return single; </p>
<p>  } </p>
<p>}</p>
<p> 懒汉式：</p>
<p>//懒汉式单例类.在第一次调用的时候实例化自己  </p>
<p>public class Singleton { </p>
<p>  private Singleton() {} </p>
<p>  private static Singleton single=null; </p>
<p>  //静态工厂方法  </p>
<p>  public static Singleton getInstance() { </p>
<p>​     if (single == null) {  </p>
<p>​       single = new Singleton(); </p>
<p>​     }  </p>
<p>​    return single; </p>
<p>  } </p>
<p>} </p>
<p> 饿汉式就是类一旦加载，就把单例初始化完成，保证getInstance()的时候，单例就已经存在。</p>
<p> 懒汉式比较懒，只有当调用getInstance的时候，才会去初始化这个单例</p>
<p>区别：</p>
<p> 饿汉式是线程安全的，懒汉式是线程不安全的（即一个进程内有多个线程在在同时使用时可能会产生多个实例，可创建个静态内部类，产生一个单例对象，通过静态内部类返回获取这个对象）</p>
<p><strong>43.</strong>   <strong>常见的基本排序</strong></p>
<p> 冒泡排序</p>
<p>public void bubbleSort(int[] arr) { //从小到大</p>
<p>​     int temp = 0;</p>
<p>​     for(int i = 0; i &lt; arr.length -1; i++){ //控制趟数，到倒数第二个为止</p>
<p>​          for(int j = arr.length-1; j&gt;i; j–){ //从最后一个值开始冒泡，将后面的小值与前面的大值进行交换，并且保证循环到前面已经排序完的索引为止</p>
<p>​              if(arr[j-1] &gt; arr[j]){</p>
<p>​                   temp = arr[j];</p>
<p>​                   arr[j] = arr[j-1];</p>
<p>​                   arr[j-1] = temp;</p>
<p>​              }</p>
<p>​          }</p>
<p>​     }</p>
<p>}</p>
<p>选择排序：</p>
<p>public void selectionSort(int[] arr){</p>
<p>​     int temp = 0;</p>
<p>​     int k = 0; //存储最小值的索引</p>
<p>​     for(int i = 0; i&lt;arr.lengrh - 1; i++){ //控制趟数，到倒数第二个为止</p>
<p>​          k = i;</p>
<p>​          for(int j = i; j&lt;arr.length;j++){ //将第一个数默认为最小值，将其索引赋值给k，从k索引开始，将后面每个数与k索引对应的值比较，如果值小了，就将其索引赋值给k</p>
<p>​              if(arr[j] &lt; arr[k]){</p>
<p>​                   k = j;</p>
<p>​              }</p>
<p>​          }</p>
<p>​          //遍历完后，k就指向了最小的值，将其与i对应的值交换(也可 以先做个判断，判断k的索引是否有变化，无变化可以不交换)</p>
<p>​          temp = arr[k];</p>
<p>​          arr[k] = arr[i];</p>
<p>​          arr[i] = temp;</p>
<p>​     }</p>
<p>​     </p>
<p>}</p>
<p><strong>44.</strong>   <strong>常见设计模式</strong></p>
<p> 工厂模式：一个抽象接口的实现，多个抽象接口的实现类，spring的beanFactory就是工厂模式</p>
<p> 单例模式：在内存中，保证对象的实例只有一个。</p>
<p> 装饰者模式：对一个类进行装饰，增强其方法行为，如Java中的IO流就使用了装饰者模式</p>
<p> 代理模式：比如sping AOP使用动态代理</p>
<p> 适配器模式：io流，通过继承实现将一个接口适配到另一个接口，InputStreamReader类继承Reader接口，但要创建它们必须在构造函数中传入一个InputStream的实例，InputStreamReader的作用也就是将InputStream适配到Reader</p>
<p> 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">随风-而动</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2020/08/01/java%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%85%B6%E4%B8%80/">http://yoursite.com/2020/08/01/java面试题-其一/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://yoursite.com">随风-而动的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#java基础"><span class="toc-number">1.</span> <span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-JDK和-JRE-有什么区别？"><span class="toc-number">1.1.</span> <span class="toc-text">1.JDK和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Java-内存区域"><span class="toc-number">1.2.</span> <span class="toc-text">2.Java 内存区域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-和-equals-的区别是什么？"><span class="toc-number">1.3.</span> <span class="toc-text">3. &#x3D;&#x3D; 和 equals 的区别是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-final-在-Java-中有什么作用？"><span class="toc-number">1.4.</span> <span class="toc-text">4. final 在 Java 中有什么作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-String-类的常用方法都有那些？"><span class="toc-number">1.5.</span> <span class="toc-text">5. String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-Java-容器都有哪些？"><span class="toc-number">1.6.</span> <span class="toc-text">6. Java 容器都有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-数组与链表的区别"><span class="toc-number">1.7.</span> <span class="toc-text">7. 数组与链表的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-Map集合几种遍历方式"><span class="toc-number">1.8.</span> <span class="toc-text">8. Map集合几种遍历方式?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-List集合的特性"><span class="toc-number">1.9.</span> <span class="toc-text">9. List集合的特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-如何实现数组和-List-之间的转换？"><span class="toc-number">1.10.</span> <span class="toc-text">10. 如何实现数组和 List 之间的转换？</span></a></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2020/08/02/SpringCloud-Bug/">&lt; SpringCloud Bug</a><a class="next" href="/2020/07/31/RabbitMQ%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BA%8C/">RabbitMQ学习(其二) &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2020 <a href="/." rel="nofollow">Hexo</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = '{config.search.path}';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>